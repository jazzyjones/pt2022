{"title":"Plano de Trabalho - teste inicial","markdown":{"yaml":{"title":"Plano de Trabalho - teste inicial","author":"Joaquim","date":"12/19/2022","format":{"html":{"code-fold":true,"fig-height":4,"fig-width":5}},"execute":{"freeze":true,"warning":false}},"headingText":"Carregando bibliotecas","containsRefs":false,"markdown":"\n\n\n\n\n```{r}\nlibrary(tidyverse)\nlibrary(data.table)\nlibrary(sf)\nlibrary(units)\n\n```\n\n## *locale* e *crs*\n\n```{r}\n##### Pesquisar depois e adaptar para utilizar o pacote geobr ao invés dos geopackages\n\nSys.setenv(LANG = \"English\")\n\n#\n# CRS para cálculo de áreas - \n# A Diretoria de Geociências – DGC do IBGE através da Coordenação de Cartografia - CCAR, elaborou um estudo (FRANÇA e MARANHÃO, 2015)\n# de geração de uma grade estatística para o Brasil buscando minimizar as distorções decorrentes da grande extensão territorial do país.\n# Neste contexto, foi feita a opção pela utilização da Projeção Equivalente de Albers, que apresenta como característica principal \n# a equivalência em área. Essa projeção é formada por um cone ao redor do globo, sob o qual as feições da superfície terrestre são \n# projetadas. Este cone intercepta o globo em dois paralelos padrão, com os meridianos formando linhas retas com a origem em um ponto\n# central na geratriz do cone, enquanto os paralelos formam círculos concêntricos em torno deste ponto. O datum horizontal adotado é o\n# SIRGAS2000.\n# \n# Os parâmetros da projeção adotada são:\n# Meridiano Central -54º\n# Latitude de Origem -12º\n# 1º Paralelo Padrão -2º\n# 2º Paralelo Padrão -22º\n# Origem E: 5.000.000\n# Origem N: 10.000.000\n# Área de Abrangência canto inferior esquerdo (E,N):\n#   2.800.000, 7.350.000\n# canto superior direito (E,N):\n#   8.210.000, 12.200.000\n#\n# https://spatialreference.org/ref/sr-org/albers-conical-equal-area-brazil-sirgas-2000/\n#\n# +proj=aea +lat_1=-2 +lat_2=-22 +lat_0=-12 +lon_0=-54 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\n#\n\n# endereço do arquivo geopackage com as camadas de amostragem para calculo dos coeficientes dos municípios\n\n\n\nProj_IBGE_area <- 'PROJCS[\"Conica_Equivalente_de_Albers_Brasil\",\n                         GEOGCS[\"GCS_SIRGAS2000\",\n                                DATUM[\"D_SIRGAS2000\",\n                                      SPHEROID[\"Geodetic_Reference_System_of_1980\",6378137,298.2572221009113]],\n                                PRIMEM[\"Greenwich\",0],\n                                UNIT[\"Degree\",0.017453292519943295]],\n                         PROJECTION[\"Albers\"],\n                         PARAMETER[\"standard_parallel_1\",-2],\n                         PARAMETER[\"standard_parallel_2\",-22],\n                         PARAMETER[\"latitude_of_origin\",-12],\n                         PARAMETER[\"central_meridian\",-54],\n                         PARAMETER[\"false_easting\",5000000],\n                         PARAMETER[\"false_northing\",10000000],\n                         UNIT[\"Meter\",1]]'\n\n```\n\n## Áreas urbanizadas 2015\n\n```{r}\nBegin_time <- Sys.time()\n\n# Carrega camada do Areas urbanizadas\nAreasUrb2015 <- st_read(\"C:/ACELERADOR/Bases/AreasUrbanizadas2015.gpkg\",\n                        query = \"SELECT Densidade, Tipo, CodConcUrb, geom FROM AreasUrbanizadas2015_CorrecaoTopologia\")\n\nend_time <- Sys.time()\nTempo_areasurb <- end_time - Begin_time\n```\n\n## Municípios\n\n```{r}\nstart_time <- Sys.time()\n\n# Carrega camada dos municípios\nMunicipios <- st_read(\"C:/ACELERADOR/Bases/MUNICIPIOS.gpkg\",\n                      layer = \"BRMUE250GC_SIR_2010\")\n\n# Repara erro de topologia dos municípios\nMunicipios <- st_make_valid(Municipios)\n\n# Seleciona os municípios que interseccionam a camada de áreas urbanizadas (mapeados)\nMunicipios_proc <- Municipios[AreasUrb2015, op = st_intersects]\n\n# Remove a camada original de municípios para liberar memória\nrm(Municipios)\ngc()\n\n# Cria a sequência de geocódigos dos municípios\nListaMun <- Municipios_proc$CD_GEOCODM\n# ListaMun <- Municipios_proc$CD_GEOCODM[Municipios_proc$NM_MUNICIP == \"RIO DE JANEIRO\"]\nListaMun <- ListaMun[1]\n# ListaMun <- c(\"2307700\", \"2304202\") # município que tá dando erro\n# ListaMun <- c(\"3124104\", \"3136652\", \"3130101\", \"3106705\", \"3162922\", \"3109006\", \"3140159\", \"3165537\", \"3149309\",\n#               \"3118601\", \"3154606\", \"3129806\", \"3106200\", \"3162955\", \"3144805\", \"3171204\", \"3117876\", \"3137601\",\n#               \"3157807\", \"3156700\", \"3153905\", \"3154804\", \"3110004\") ## BH\n\nend_time <- Sys.time()\nTempo_municipios <- end_time - start_time\n```\n\n## *loop* de geoprocessamento\n\n```{r}\nstart_time <- Sys.time()\n\n# Cria a lista vazia para receber os data.frames / sf interseccionados e com áreas calculadas\nTabelaCalcCoef <- list()\n\n# loop para intersecao das bases e calculo de areas\nfor (i in ListaMun) {\n  \n  # Seleciona e o município\n  Mun <- Municipios_proc %>%\n    filter(CD_GEOCODM == i)\n  \n  # extrai a geometria do municipio e converte para texto\n  Mun_wkt <- Mun %>%\n    st_geometry() %>%\n    st_as_text()\n  \n  # carrega a grade estatistica filtrando com a geometria do municipio\n  grade <- st_read(\"C:/ACELERADOR/Bases/GradeEstatistica.gpkg\",\n                   query = \"SELECT ID_UNICO, POP, DOM_OCU, Shape_Area as AreaGrade, geom FROM GradeEstatistica\",\n                   wkt_filter = Mun_wkt)\n  \n  # seleciona as celulas da grade que estejam completamente dentro do municipio\n  grade <- grade[Mun, op = st_within]\n  \n  # reprojeta a grade para coordenadas planas\n  grade <- st_transform(grade, Proj_IBGE_area)\n  \n  # cria a query dos setores \n  query_setor <- str_c(\"SELECT CD_GEOCODI, CD_GEOCODS, CD_GEOCODD, CD_GEOCODM, NM_MUNICIP, UF, geom FROM 'SETORES CENSITÁRIOS' WHERE CD_GEOCODM = \", i)\n  \n  # carrega os setores censitarios do municipio\n  setores <- st_read(\"C:/ACELERADOR/Bases/BASE_2010.gpkg\",\n                     query = query_setor)\n  \n  # reprojeta os setores para coordenadas planas\n  setores <- st_transform(setores, Proj_IBGE_area)\n  \n  # seleciona as áreas urbanizadas que interseccionem o município\n  areas_urb <- AreasUrb2015[Mun, op = st_intersects]\n  \n  # reprojeta as áreas urbanizadas para coordenadas planas\n  areas_urb <- st_transform(areas_urb, Proj_IBGE_area)\n  \n  # interseciona a grade com os setores \n  intersecao <- st_intersection(grade, setores)\n  \n  # interseciona a camada de grade+setores com as areas urbanizadas\n  intersecao_urb <- st_intersection(intersecao, areas_urb)\n  \n  # cria a camada diferenca de grade+setores com as areas urbanizdas\n  diferenca_urb <- st_difference(intersecao, st_union(areas_urb))\n  \n  # junta as duas camadas - grade+setores+areas urbanizadas e grade+setor-areas urbanizadas\n  intersecao <- bind_rows(intersecao_urb, diferenca_urb)\n  \n  # calcula as áreas dos segmentos resultantes\n  tabela_areas <- intersecao %>%\n    mutate(Area_Inter = st_area(intersecao))\n  \n  # exporta para um geopackage para avaliação\n  st_write(st_transform(tabela_areas, crs = 4674), dsn = \"C:/ACELERADOR/EsPop_coef.gpkg\", layer = i, append = FALSE)\n  \n  # converte para numeros, sem unidade\n  attributes(tabela_areas$Area_Inter) <- NULL\n  \n  # remove a geometria para liberar memoria\n  st_geometry(tabela_areas) <- NULL\n  gc()\n  \n  # insere na lista de tabelas\n  TabelaCalcCoef[[i]] = tabela_areas\n}\n\nend_time <- Sys.time()\nTempo_geoproc <- end_time - start_time\n```\n\n## Consolidação da tabela de cálculo e limpeza da memória\n\n```{r}\nstart_time <- Sys.time()\n\n# consolida a tabela de calculo a partir da lista de tabelas\nTabelaCalcCoef <- bind_rows(TabelaCalcCoef)\n\n# limpa a memoria de objetos não mais necessarios\n# rm(list = setdiff(ls(), c(\"TabelaCalcCoef\", \"ListaMun\", \"Begin_time\", \"start_time\", \"Tempo_areasurb\", \"Tempo_municipios\", \"Tempo_geoproc\")))\ngc()\n\nend_time <- Sys.time()\nTempo_cons <- end_time - start_time\n```\n\n## Somatório das áreas por setor / classe\n\n```{r}\nstart_time <- Sys.time()\n\n# remove as unidades de área (m^2)\nTabelaCalcCoef <- drop_units(TabelaCalcCoef)\n\n# soma as áreas totais dos setores por classe de densidade usando data.table\nsetDT(TabelaCalcCoef)\nTabelaCalcCoef <- (\n  TabelaCalcCoef\n  [, ClasseUrb := fcase(Tipo == \"Área urbanizada\" & Densidade == \"Densa\", \"UrDs\",\n                        Tipo == \"Área urbanizada\" & Densidade == \"Pouco densa\", \"UrPd\",\n                        Tipo == \"Outros equipamentos urbanos\", \"NRes\",\n                        Tipo == \"Vazio intraurbano\", \"Vaz\", is.na(Tipo), \"Vaz\")]\n  [ClasseUrb == \"UrDs\", AreUrDsSet := sum(Area_Inter), by = CD_GEOCODI]\n  [ClasseUrb == \"UrPd\", AreUrPdSet := sum(Area_Inter), by = CD_GEOCODI]\n  [ClasseUrb == \"NRes\", AreNResSet := sum(Area_Inter), by = CD_GEOCODI]\n  [ClasseUrb == \"Vaz\", AreaVazSet := sum(Area_Inter), by = CD_GEOCODI]\n  [is.na(AreUrDsSet), AreUrDsSet := 0]\n  [is.na(AreUrPdSet), AreUrPdSet := 0]\n  [is.na(AreNResSet), AreNResSet := 0]\n  [is.na(AreaVazSet), AreaVazSet := 0]\n  [, AreUrDsSet := max(AreUrDsSet), by = CD_GEOCODI]\n  [, AreUrPdSet := max(AreUrPdSet), by = CD_GEOCODI]\n  [, AreNResSet := max(AreNResSet), by = CD_GEOCODI]\n  [, AreaVazSet := max(AreaVazSet), by = CD_GEOCODI]\n)\nend_time <- Sys.time()\nTempo_calcarea <- end_time - start_time\n```\n\n## Preparo da tabela para procedimento de otimização\n\n```{r}\nstart_time <- Sys.time()\n\n# remove segmentos sem associacao com grade ou setor (problemas de topologia)\nTabelaCalcCoef <- na.omit(TabelaCalcCoef, cols = c(\"CD_GEOCODI\", \"ID_UNICO\"))\n\n# Cria lista de setores\nListaSet <- unique(TabelaCalcCoef$CD_GEOCODI)\nstr_c(ListaSet, collapse = \", \")\n\n# cria a query com os geocodigos dos setores\nquery_set <- str_glue(\"SELECT Cod_setor, V001, V002 FROM 'Basico' WHERE Cod_setor IN (\", str_c(ListaSet, collapse = \", \"), \")\", collapse = \"\")\n\n# Carrega a tabela de variáveis dos setores\nVarSetores <- st_read(\"C:/ACELERADOR/Bases/BASE_2010.gpkg\",\n                      query = query_set)\n\n# Converte as variaveis populacao e domicilio para numerico e renomeia a variavel de geocodigo do setor\nVarSetores <- as.data.table(VarSetores)\nVarSetores <- VarSetores[, ':='(V001 = as.numeric(V001),\n                                V002 = as.numeric(V002),\n                                CD_GEOCODI = Cod_setor)]\n\n# Associa as variaveis domicilios e moradores dos setores a tabela de calculo\nTabelaCalcCoef <- VarSetores[TabelaCalcCoef, on = \"CD_GEOCODI\"]\n\n# assigna o valor 0 para os setores sem valor nas variáveis V001 e V002\nTabelaCalcCoef <- (\n  TabelaCalcCoef[is.na(V001), V001 := 0]\n  [is.na(V002), V002 := 0]\n)\n\n# Cria variaveis de controle de amostra e seleciona as colunas relevantes\nTabelaCalcCoef <- (\n  TabelaCalcCoef\n  [, NC_Cont := uniqueN(ClasseUrb), by = CD_GEOCODI]\n  [, grd_amostra := fifelse(any(NC_Cont > 1), TRUE, FALSE), by = ID_UNICO]\n  [, ':=' (N_SubD = uniqueN(CD_GEOCODS), N_Dist = uniqueN(CD_GEOCODD), N_Mun = uniqueN(CD_GEOCODM)),by = ID_UNICO]\n  [, .(CD_GEOCODI, CD_GEOCODS, CD_GEOCODD, CD_GEOCODM, NM_MUNICIP, UF, ID_UNICO, NC_Cont, grd_amostra, N_SubD, N_Dist, N_Mun,\n       POP, DOM_OCU, V001, V002, Area_Inter, ClasseUrb, AreUrDsSet, AreUrPdSet, AreNResSet, AreaVazSet)]\n)\n\n# ordena segundo o geocodigo do setor - crescente\nsetorder(TabelaCalcCoef, CD_GEOCODI)\n\n# pivota a tabela, com o total das áreas por classe para cada segmento\nTabelaCalcCoef <- dcast(TabelaCalcCoef, ... ~ ClasseUrb,\n                        fun = sum,\n                        value.var = \"Area_Inter\",\n                        fill = 0)\n\n# verifica a existência das colunas de áreas por classe dos segmentos, e cria as faltantes com valor 0\ncolunas <- c(\"UrDs\", \"UrPd\", \"NRes\", \"Vaz\")\nsetDF(TabelaCalcCoef)\nTabelaCalcCoef[colunas[!(colunas %in% colnames(TabelaCalcCoef))]] = 0  # semantica de Base R... devo tentar entender em algum momento\nsetDT(TabelaCalcCoef)\n\n# elimina segmentos que não pertencem à células da grade utilizadas na amostra - tabela final para calculo\nTabelaCalcCoef <- TabelaCalcCoef[grd_amostra == TRUE]\n\n## Integrar a parte de calculo dos coeficientes\n\nend_time <- Sys.time()\nTempo_tabela <- end_time - start_time\n```\n\n## Declaração das variáveis e funcões para otimização\n\n```{r}\nstart_time <- Sys.time()\n\npar.ini <- c(1, 1, 1, 1)\nubound <- c(10^9, 10^9, 10^9, 10^9) # testar pra ver se resolve os erros\nlbound <- c(10^-9, 10^-9, 10^-9, 10^-9)\nSubd <- unique(TabelaCalcCoef$CD_GEOCODS)\nDist <- unique(TabelaCalcCoef$CD_GEOCODD)\nMun <- unique(TabelaCalcCoef$CD_GEOCODM)\n\nSubD_coef_dpp <- list()\nDist_coef_dpp <- list()\nMun_coef_dpp <- list()\n\n# função usando o data.table\nfnopt_pop <- function(par, data) {\n  (\n    data\n    [, POPEstTrecho := V002 * ((UrDs * par[1]) + (UrPd * par[2]) + (Vaz * par[3]) + (NRes * par[4]))\n      / ((AreUrDsSet * par[1]) + (AreUrPdSet * par[2]) + (AreaVazSet * par[3]) + (AreNResSet * par[4]))]\n    [, .(POPEst = sum(POPEstTrecho), POPGde = first(POP)), by = \"ID_UNICO\"]\n    [, Erro := abs(POPGde - POPEst)]\n    [, .(total = sum(Erro))]\n  )\n}\n\nfnopt_dom <- function(par, data) {\n  (\n    data\n    [, DOMEstTrecho := V001 * ((UrDs * par[1]) + (UrPd * par[2]) + (Vaz * par[3]) + (NRes * par[4]))\n      / ((AreUrDsSet * par[1]) + (AreUrPdSet * par[2]) + (AreaVazSet * par[3]) + (AreNResSet * par[4]))]\n    [, .(DOMEst = sum(DOMEstTrecho), DOMGde = first(DOM_OCU)), by = \"ID_UNICO\"]\n    [, Erro := abs(DOMGde - DOMEst)]\n    [, .(total = sum(Erro))]\n  )\n}\n\nend_time <- Sys.time()\nTempo_vars <- end_time - start_time\n```\n\n## Cálculo dos coeficientes - população - subdistrito\n\n```{r}\nstart_time <- Sys.time()\n\nfor (i in Subd) {\n  selecao <- TabelaCalcCoef[N_SubD == 1 & CD_GEOCODS == i]\n  amostra <- n_distinct(selecao$ID_UNICO)\n  result_pop <- try(optim(par = par.ini, fn = fnopt_pop, data = selecao, method = \"L-BFGS-B\", lower = lbound))\n  SubD_coef_dpp[[i]] = data.frame(i)\n  SubD_coef_dpp[[i]]$CD_GEOCODS = i\n  SubD_coef_dpp[[i]]$pop_coefDS_SubD = ifelse(class(result_pop) == \"list\", result_pop$par[1], NA)\n  SubD_coef_dpp[[i]]$pop_coefPD_SubD = ifelse(class(result_pop) == \"list\", result_pop$par[2], NA)\n  SubD_coef_dpp[[i]]$pop_coefVZ_SubD = ifelse(class(result_pop) == \"list\", result_pop$par[3], NA)\n  SubD_coef_dpp[[i]]$pop_coefNR_SubD = ifelse(class(result_pop) == \"list\", result_pop$par[4], NA)\n  SubD_coef_dpp[[i]]$amostra_SubD = amostra\n}\n\nCoefs_SubD_pop <- bind_rows(SubD_coef_dpp) %>%\n  select(CD_GEOCODS, amostra_SubD, pop_coefDS_SubD, pop_coefPD_SubD, pop_coefVZ_SubD, pop_coefNR_SubD)\n\nend_time <- Sys.time()\nTempo_subdist_pop <- end_time - start_time\n```\n\n## Cálculo dos coeficientes - domicílio - subdistrito\n\n```{r}\nstart_time <- Sys.time()\n\nfor (i in Subd) {\n  selecao <- TabelaCalcCoef[N_SubD == 1 & CD_GEOCODS == i]\n  amostra <- n_distinct(selecao$ID_UNICO)\n  result_dom <- try(optim(par = par.ini, fn = fnopt_dom, data = selecao, method = \"L-BFGS-B\", lower = lbound))\n  SubD_coef_dpp[[i]] = data.frame(i)\n  SubD_coef_dpp[[i]]$CD_GEOCODS = i\n  SubD_coef_dpp[[i]]$dom_coefDS_SubD = ifelse(class(result_dom) == \"list\", result_dom$par[1], NA)\n  SubD_coef_dpp[[i]]$dom_coefPD_SubD = ifelse(class(result_dom) == \"list\", result_dom$par[2], NA)\n  SubD_coef_dpp[[i]]$dom_coefVZ_SubD = ifelse(class(result_dom) == \"list\", result_dom$par[3], NA)\n  SubD_coef_dpp[[i]]$dom_coefNR_SubD = ifelse(class(result_dom) == \"list\", result_dom$par[4], NA)\n  SubD_coef_dpp[[i]]$amostra_SubD = amostra\n}\n\nCoefs_SubD_dom <- bind_rows(SubD_coef_dpp) %>%\n  select(CD_GEOCODS, amostra_SubD, dom_coefDS_SubD, dom_coefPD_SubD, dom_coefVZ_SubD, dom_coefNR_SubD)\n\nend_time <- Sys.time()\nTempo_subdist_dom <- end_time - start_time\n```\n\n## Cálculo dos coeficientes - população - distrito\n\n```{r}\nstart_time <- Sys.time()\n\nfor (i in Dist) {\n  selecao <- TabelaCalcCoef[N_Dist == 1 & CD_GEOCODD == i]\n  amostra <- n_distinct(selecao$ID_UNICO)\n  result_pop <- try(optim(par = par.ini, fn = fnopt_pop, data = selecao, method = \"L-BFGS-B\", lower = lbound))\n  Dist_coef_dpp[[i]] = data.frame(i)\n  Dist_coef_dpp[[i]]$CD_GEOCODD = i\n  Dist_coef_dpp[[i]]$pop_coefDS_Dist = ifelse(class(result_pop) == \"list\", result_pop$par[1], NA)\n  Dist_coef_dpp[[i]]$pop_coefPD_Dist = ifelse(class(result_pop) == \"list\", result_pop$par[2], NA)\n  Dist_coef_dpp[[i]]$pop_coefVZ_Dist = ifelse(class(result_pop) == \"list\", result_pop$par[3], NA)\n  Dist_coef_dpp[[i]]$pop_coefNR_Dist = ifelse(class(result_pop) == \"list\", result_pop$par[4], NA)\n  Dist_coef_dpp[[i]]$amostra_Dist = amostra\n}\n\nCoefs_Dist_pop <- bind_rows(Dist_coef_dpp) %>%\n  select(CD_GEOCODD, amostra_Dist, pop_coefDS_Dist, pop_coefPD_Dist, pop_coefVZ_Dist, pop_coefNR_Dist)\n\nend_time <- Sys.time()\nTempo_dist_pop <- end_time - start_time\n```\n\n## Cálculo dos coeficientes - domicílio - distrito\n\n```{r}\nstart_time <- Sys.time()\n\nfor (i in Dist) {\n  selecao <- TabelaCalcCoef[N_Dist == 1 & CD_GEOCODD == i]\n  amostra <- n_distinct(selecao$ID_UNICO)\n  result_dom <- try(optim(par = par.ini, fn = fnopt_dom, data = selecao, method = \"L-BFGS-B\", lower = lbound))\n  Dist_coef_dpp[[i]] = data.frame(i)\n  Dist_coef_dpp[[i]]$CD_GEOCODD = i\n  Dist_coef_dpp[[i]]$dom_coefDS_Dist = ifelse(class(result_dom) == \"list\", result_dom$par[1], NA)\n  Dist_coef_dpp[[i]]$dom_coefPD_Dist = ifelse(class(result_dom) == \"list\", result_dom$par[2], NA)\n  Dist_coef_dpp[[i]]$dom_coefVZ_Dist = ifelse(class(result_dom) == \"list\", result_dom$par[3], NA)\n  Dist_coef_dpp[[i]]$dom_coefNR_Dist = ifelse(class(result_dom) == \"list\", result_dom$par[4], NA)\n  Dist_coef_dpp[[i]]$amostra_Dist = amostra\n}\n\nCoefs_Dist_dom <- bind_rows(Dist_coef_dpp) %>%\n  select(CD_GEOCODD, amostra_Dist, dom_coefDS_Dist, dom_coefPD_Dist, dom_coefVZ_Dist, dom_coefNR_Dist)\n\nend_time <- Sys.time()\nTempo_dist_dom <- end_time - start_time\n```\n\n## Cálculo dos coeficientes - população - municípios\n\n```{r}\nstart_time <- Sys.time()\n\nfor (i in Mun) {\n  selecao <- TabelaCalcCoef[N_Mun == 1 & CD_GEOCODM == i]\n  amostra <- n_distinct(selecao$ID_UNICO)\n  result_pop <- try(optim(par = par.ini, fn = fnopt_pop, data = selecao, method = \"L-BFGS-B\", lower = lbound))\n  Mun_coef_dpp[[i]] = data.frame(i)\n  Mun_coef_dpp[[i]]$CD_GEOCODM = i\n  Mun_coef_dpp[[i]]$pop_coefDS_Mun = ifelse(class(result_pop) == \"list\", result_pop$par[1], NA)\n  Mun_coef_dpp[[i]]$pop_coefPD_Mun = ifelse(class(result_pop) == \"list\", result_pop$par[2], NA)\n  Mun_coef_dpp[[i]]$pop_coefVZ_Mun = ifelse(class(result_pop) == \"list\", result_pop$par[3], NA)\n  Mun_coef_dpp[[i]]$pop_coefNR_Mun = ifelse(class(result_pop) == \"list\", result_pop$par[4], NA)\n  Mun_coef_dpp[[i]]$amostra_Mun = amostra\n}\n\nCoefs_Mun_pop <- bind_rows(Mun_coef_dpp) %>%\n  select(CD_GEOCODM, amostra_Mun, pop_coefDS_Mun, pop_coefPD_Mun, pop_coefVZ_Mun, pop_coefNR_Mun)\n\nend_time <- Sys.time()\nTempo_mun_pop <- end_time - start_time\n```\n\n## Cálculo dos coeficientes - domicílio - municípios\n\n```{r}\nstart_time <- Sys.time()\n\nfor (i in Mun) {\n  selecao <- TabelaCalcCoef[N_Mun == 1 & CD_GEOCODM == i]\n  amostra <- n_distinct(selecao$ID_UNICO)\n  result_dom <- try(optim(par = par.ini, fn = fnopt_dom, data = selecao, method = \"L-BFGS-B\", lower = lbound))\n  Mun_coef_dpp[[i]] = data.frame(i)\n  Mun_coef_dpp[[i]]$CD_GEOCODM = i\n  Mun_coef_dpp[[i]]$dom_coefDS_Mun = ifelse(class(result_dom) == \"list\", result_dom$par[1], NA)\n  Mun_coef_dpp[[i]]$dom_coefPD_Mun = ifelse(class(result_dom) == \"list\", result_dom$par[2], NA)\n  Mun_coef_dpp[[i]]$dom_coefVZ_Mun = ifelse(class(result_dom) == \"list\", result_dom$par[3], NA)\n  Mun_coef_dpp[[i]]$dom_coefNR_Mun = ifelse(class(result_dom) == \"list\", result_dom$par[4], NA)\n  Mun_coef_dpp[[i]]$amostra_Mun = amostra\n}\n\nCoefs_Mun_dom <- bind_rows(Mun_coef_dpp) %>%\n  select(CD_GEOCODM, amostra_Mun, dom_coefDS_Mun, dom_coefPD_Mun, dom_coefVZ_Mun, dom_coefNR_Mun)\n\nend_time <- Sys.time()\nTempo_mun_dom <- end_time - start_time\n```\n\n## Etapas finais\n\n```{r}\nstart_time <- Sys.time()\n\n\nrm(list = setdiff(ls(), c(\"Coefs_SubD_pop\", \"Coefs_SubD_dom\", \"Coefs_Dist_pop\", \"Coefs_Dist_dom\", \"Coefs_Mun_pop\", \"Coefs_Mun_dom\",\n                          \"TabelaCalcCoef\", \"Tempo_areasurb\", \"Tempo_municipios\", \"Tempo_geoproc\", \"Tempo_tabela\", \"Tempo_vars\", \"Tempo_subdist_pop\",\n                          \"Tempo_subdist_dom\", \"Tempo_dist_pop\", \"Tempo_dist_dom\", \"Tempo_mun_pop\", \"Tempo_mun_dom\", \"Tempo_coefs\", \"Tempo_Total\", \"start_time\", \"Tempo_cons\", \"Tempo_calcarea\", \"Begin_time\")))\n\n\n\nSubD_pop_erro <- Coefs_SubD_pop$CD_GEOCODS[is.na(c(Coefs_SubD_pop$pop_coefDS_SubD))]\nSubD_dom_erro <- Coefs_SubD_dom$CD_GEOCODS[is.na(c(Coefs_SubD_dom$dom_coefDS_SubD))]\nDist_pop_erro <- Coefs_Dist_pop$CD_GEOCODD[is.na(c(Coefs_Dist_pop$pop_coefDS_Dist))]\nDist_dom_erro <- Coefs_Dist_dom$CD_GEOCODD[is.na(c(Coefs_Dist_dom$dom_coefDS_Dist))]\nMun_pop_erro <- Coefs_Mun_pop$CD_GEOCODM[is.na(c(Coefs_Mun_pop$pop_coefDS_Mun))]\nMun_dom_erro <- Coefs_Mun_dom$CD_GEOCODM[is.na(c(Coefs_Mun_dom$dom_coefDS_Mun))]\n\n# st_write(Coefs_SubD_pop, dsn = \"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/_GPKG/EstPop.gpkg\", layer = \"Coefs_SubD_pop\", append = FALSE)\n# st_write(Coefs_SubD_dom, dsn = \"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/_GPKG/EstPop.gpkg\", layer = \"Coefs_SubD_dom\", append = FALSE)\n# st_write(Coefs_Dist_pop, dsn = \"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/_GPKG/EstPop.gpkg\", layer = \"Coefs_Dist_pop\", append = FALSE)\n# st_write(Coefs_Dist_dom, dsn = \"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/_GPKG/EstPop.gpkg\", layer = \"Coefs_Dist_dom\", append = FALSE)\n# st_write(Coefs_Mun_pop, dsn = \"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/_GPKG/EstPop.gpkg\", layer = \"Coefs_Mun_pop\", append = FALSE)\n# st_write(Coefs_Mun_dom, dsn = \"W:/DGC_ACERVO_CGEO/PROJETOS_EM_ANDAMENTO/Cemaden/BOLSISTAS/Joaquim/_GPKG/EstPop.gpkg\", layer = \"Coefs_Mun_dom\", append = FALSE)\n\nend_time <- Sys.time()\nTempo_coefs <- end_time - start_time\nTempo_Total <- end_time - Begin_time\n\nTempo_areasurb\nTempo_municipios\nTempo_geoproc\nTempo_cons\nTempo_calcarea\nTempo_tabela\nTempo_vars\nTempo_subdist_pop\nTempo_subdist_dom\nTempo_dist_pop\nTempo_dist_dom\nTempo_mun_pop\nTempo_mun_dom\nTempo_coefs\nTempo_Total\n``` "},"formats":{"html":{"execute":{"fig-width":5,"fig-height":4,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","theme":"cosmo","title":"Plano de Trabalho - teste inicial","author":"Joaquim","date":"12/19/2022"},"extensions":{"book":{"multiFile":true}}}}}